"use strict";(self.webpackChunk_0xsequence_docs=self.webpackChunk_0xsequence_docs||[]).push([[1548],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return n?r.createElement(m,s(s({ref:t},u),{},{components:n})):r.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7408:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={},s="Authenticate Users with Message Signature",i={unversionedId:"wallet/guides/auth-address",id:"wallet/guides/auth-address",title:"Authenticate Users with Message Signature",description:"Ask for the wallet address",source:"@site/docs/03-wallet/04-guides/02-auth-address.mdx",sourceDirName:"03-wallet/04-guides",slug:"/wallet/guides/auth-address",permalink:"/wallet/guides/auth-address",draft:!1,editUrl:"https://github.com/0xsequence/docs/edit/master/docs/03-wallet/04-guides/02-auth-address.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"sidebar",previous:{title:"Connect Wallet",permalink:"/wallet/guides/connect-wallet"},next:{title:"Signing & Verifying Messages",permalink:"/wallet/guides/sign-message"}},l={},c=[{value:"Ask for the wallet address",id:"ask-for-the-wallet-address",level:2},{value:"Authenticate wallet",id:"authenticate-wallet",level:2},{value:"Authenticate wallet server-side",id:"authenticate-wallet-server-side",level:2}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"authenticate-users-with-message-signature"},"Authenticate Users with Message Signature"),(0,a.kt)("h2",{id:"ask-for-the-wallet-address"},"Ask for the wallet address"),(0,a.kt)("p",null,"To get the user's Sequence wallet address:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const wallet = sequence.getWallet()\nconst address = wallet.getAddress()\nconsole.log(address)\n")),(0,a.kt)("h2",{id:"authenticate-wallet"},"Authenticate wallet"),(0,a.kt)("p",null,"In many cases, you'll want your users to connect and then verify they do control this wallet address. Applications typically do this by asking the user\nto sign a message with their wallet, and then verify the signature from the user to ensure its integrity."),(0,a.kt)("p",null,"As this is such a common workflow, Sequence can automatically authenticate the account address at the same time\nwhile the user is prompt to connect their wallet to your dapp. This allows the user experience to be simpler and\nmore seamless."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { sequence } from '0xsequence'\n\nconst wallet = sequence.getWallet()\n\nconst connectDetails = await wallet.connect({\n  app: 'Your Dapp name',\n  authorize: true // <---<<< this will automatically sign+verify a EIP712 message when user clicks \"Connect\"\n})\n")),(0,a.kt)("p",null,"It will look like this to your users:  "),(0,a.kt)("img",{alt:"Sequence on-demand sign in, connect",src:"/img/authorize_connect.png",width:"400"}),(0,a.kt)("p",null,"In the above example, we pass ",(0,a.kt)("inlineCode",{parentName:"p"},"authorize: true")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()")," function, which will automatically have the user\nsign a ",(0,a.kt)("strong",{parentName:"p"},"EIP712 signed message")," to prove their identity. This allows you to then easily authenticate the connected\nwallet address with absolute certainty."),(0,a.kt)("p",null,"You can find the signed message proof returned in ",(0,a.kt)("inlineCode",{parentName:"p"},"connectDetails.proof"),", which is an EIP712 signed object using\na simple convention from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/0xsequence/ethauth.js"},"ethauth"),". NOTE: EIP712 allows you to use an actual object for\nsigning instead of just a plain-text string."),(0,a.kt)("h2",{id:"authenticate-wallet-server-side"},"Authenticate wallet server-side"),(0,a.kt)("p",null,"The above example demonstrates how to connect and verify the user's identity in your dapp on the client-side,\nbut if you'd like to authenticate the Sequence authorization proof on your server, then you can do so with the following snippet:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { ValidateSequenceWalletProof } from '@0xsequence/auth'\nimport { commons, v2 } from '@0xsequence/core'\nimport { ETHAuth } from '@0xsequence/ethauth'\nimport { trackers } from '@0xsequence/sessions'\nimport * as ethers from 'ethers'\n\n// ...\n\nconst rpcUrl = 'https://polygon-mainnet.infura.io/v3/<your infura key here>'\nconst provider = new ethers.providers.JsonRpcProvider(rpcUrl)\n\n// create an EIP-6492-aware ETHAuth proof validator\nconst validator = ValidateSequenceWalletProof(\n  () => new commons.reader.OnChainReader(provider),\n  new trackers.remote.RemoteConfigTracker('https://sessions.sequence.app'),\n  v2.DeployedWalletContext\n)\nconst ethauth = new ETHAuth(validator)\nawait ethauth.configJsonRpcProvider(rpcUrl)\n\ntry {\n  const proof = await ethAuth.decodeProof(connectDetails.proof.proofString)\n  console.log(`proof for address ${proof.address} is valid`)\n} catch (err) {\n  console.log(`invalid proof -- do not trust address: ${err}`)\n}\n")),(0,a.kt)("p",null,"See the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/0xsequence/go-sequence"},"Go Sequence SDK")," on using Sequence in your Go applications."),(0,a.kt)("p",null,"If your server is written in a language other than Javascript/Typescript or Go, all you have to do is validate\nthe signature with ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP1271, the standard method for validating signed messages for a smart wallet"),"."),(0,a.kt)("p",null,"As always, if you have any questions or require help, reach out to us on ",(0,a.kt)("a",{parentName:"p",href:"https://discord.gg/sequence"},"Discord"),"."))}d.isMDXComponent=!0}}]);