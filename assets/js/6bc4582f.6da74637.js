"use strict";(self.webpackChunk_0xsequence_docs=self.webpackChunk_0xsequence_docs||[]).push([[8910],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var s=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),u=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return s.createElement(l.Provider,{value:t},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),g=u(n),d=i,h=g["".concat(l,".").concat(d)]||g[d]||p[d]||a;return n?s.createElement(h,r(r({ref:t},c),{},{components:n})):s.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[g]="string"==typeof e?e:i,r[1]=o;for(var u=2;u<a;u++)r[u]=n[u];return s.createElement.apply(null,r)}return s.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>a,metadata:()=>o,toc:()=>u});var s=n(7462),i=(n(7294),n(3905));const a={},r="No-Wallet-Confirmation Signatures",o={unversionedId:"wallet/guides/session-keys",id:"wallet/guides/session-keys",title:"No-Wallet-Confirmation Signatures",description:"It is possible to build an application where users sign messages without requiring a confirmation in their Sequence wallet every time. This is possible using session keys, or ephemeral keys.",source:"@site/docs/03-wallet/04-guides/04-session-keys.mdx",sourceDirName:"03-wallet/04-guides",slug:"/wallet/guides/session-keys",permalink:"/wallet/guides/session-keys",draft:!1,editUrl:"https://github.com/0xsequence/docs/edit/master/docs/03-wallet/04-guides/04-session-keys.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"sidebar",previous:{title:"Signing & Verifying Messages",permalink:"/wallet/guides/sign-message"},next:{title:"Sending Transactions",permalink:"/wallet/guides/send-transaction"}},l={},u=[{value:"1. Initialize Sequence Wallet and Connect",id:"1-initialize-sequence-wallet-and-connect",level:3},{value:"2. Generate a Session Key",id:"2-generate-a-session-key",level:3},{value:"3. Sign Authorization Message",id:"3-sign-authorization-message",level:3},{value:"4. Verify Authorization Signature",id:"4-verify-authorization-signature",level:3},{value:"5. Sign Message with Session Key",id:"5-sign-message-with-session-key",level:3},{value:"6. Verify Session Signature",id:"6-verify-session-signature",level:3}],c={toc:u};function g(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,s.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"no-wallet-confirmation-signatures"},"No-Wallet-Confirmation Signatures"),(0,i.kt)("p",null,"It is possible to build an application where users sign messages without requiring a confirmation in their Sequence wallet every time. This is possible using ",(0,i.kt)("em",{parentName:"p"},"session keys"),", or ephemeral keys."),(0,i.kt)("h1",{id:"session-keys"},"Session Keys"),(0,i.kt)("p",null,"Session keys are ephemeral private keys that can be generated and stored client-side, typically in a user's local storage. They provide a convenient and secure way for users to authorize specific actions in a decentralized application without requiring them to confirm each action through their primary wallet."),(0,i.kt)("p",null,"By signing a message with their primary wallet (e.g., Sequence Wallet), users can authorize a session key to act on their behalf for a limited time or scope. Applications can then interpret signed messages from the session key as if they were coming directly from the user's wallet, streamlining the user experience."),(0,i.kt)("p",null,"Session keys are particularly useful for applications that require frequent user interactions, as they help reduce the number of wallet confirmations needed, while still maintaining a secure and verifiable authentication process."),(0,i.kt)("h1",{id:"using-session-keys-with-sequence"},"Using Session keys with Sequence"),(0,i.kt)("h3",{id:"1-initialize-sequence-wallet-and-connect"},"1. Initialize Sequence Wallet and Connect"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { Wallet } from '@0xsequence/wallet'\nimport { ethers } from 'ethers'\n\nconst wallet = new Wallet()\nawait wallet.connect()\n\nconst signer = wallet.getSigner()\nconst userAddress = await signer.getAddress()\n")),(0,i.kt)("h3",{id:"2-generate-a-session-key"},"2. Generate a Session Key"),(0,i.kt)("p",null,"Create a new ephemeral private key, store it in local storage, and derive the associated address:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const sessionPrivateKey = ethers.utils.randomBytes(32)\nlocalStorage.setItem('sessionPrivateKey', ethers.utils.hexlify(sessionPrivateKey))\nconst sessionWallet = new ethers.Wallet(sessionPrivateKey)\nconst sessionAddress = await sessionWallet.getAddress()\n")),(0,i.kt)("h3",{id:"3-sign-authorization-message"},"3. Sign Authorization Message"),(0,i.kt)("p",null,"Sign a message with the user's Sequence Wallet to authorize the session key:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const authorizationMessage = `Authorize this device to play this game.`\nconst signature = await signer.signMessage(authorizationMessage)\n")),(0,i.kt)("h3",{id:"4-verify-authorization-signature"},"4. Verify Authorization Signature"),(0,i.kt)("p",null,"Verify the signature on the server or client side using Sequence utility functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const provider = wallet.getProvider()\nconst chainId = await wallet.getChainId()\n\nconst isValid = await sequence.utils.isValidMessageSignature(\n  userAddress,\n  authorizationMessage,\n  signature,\n  provider,\n  chainId\n)\n\nif (isValid) {\n  console.log('Session key authorized')\n} else {\n  console.log('Session key not authorized')\n}\n")),(0,i.kt)("h3",{id:"5-sign-message-with-session-key"},"5. Sign Message with Session Key"),(0,i.kt)("p",null,"Use the session key to sign a message client-side without user interaction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const message = 'Perform action without wallet confirmation'\nconst sessionSignature = await sessionWallet.signMessage(message)\n")),(0,i.kt)("h3",{id:"6-verify-session-signature"},"6. Verify Session Signature"),(0,i.kt)("p",null,"Verify the session signature on the server or client side:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const recoveredSessionAddress = ethers.utils.verifyMessage(message, sessionSignature)\nif (recoveredSessionAddress === sessionAddress) {\n  console.log('Session signature valid')\n} else {\n  console.log('Session signature invalid')\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": You should retrieve the session key stored in local storage upon loading the application and only create a new session key if none can be found."))}g.isMDXComponent=!0}}]);