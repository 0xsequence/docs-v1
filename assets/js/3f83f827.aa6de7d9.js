"use strict";(self.webpackChunk_0xsequence_docs=self.webpackChunk_0xsequence_docs||[]).push([[3096],{2768:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(1527),s=n(7279);const i={sidebar_label:"Metadata Tips & Spam"},r="Metadata Tips & Notes on Spam",o={id:"indexer/metadata-tips",title:"Metadata Tips & Notes on Spam",description:"The Sequence Indexer and Sequence Metadata services will pick up everything and anything",source:"@site/docs/04-indexer/08-metadata-tips.mdx",sourceDirName:"04-indexer",slug:"/indexer/metadata-tips",permalink:"/indexer/metadata-tips",draft:!1,unlisted:!1,editUrl:"https://github.com/0xsequence/docs/edit/master/docs/04-indexer/08-metadata-tips.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_label:"Metadata Tips & Spam"},sidebar:"sidebar",previous:{title:"Native network balance",permalink:"/indexer/native-network-balance"},next:{title:"Metadata",permalink:"/metadata"}},c={},d=[];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",p:"p",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"metadata-tips--notes-on-spam",children:"Metadata Tips & Notes on Spam"}),"\n",(0,a.jsxs)(t.p,{children:["The Sequence Indexer and Sequence Metadata services will pick up everything and anything\nthat is published on a blockchain. Our services are designed to provide data in real-time\nas blocks are mined, and adhere to all popular ERC20, ERC721 and ERC1155 metadata\nstandards so things ",(0,a.jsx)(t.em,{children:"just work"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"This is very helpful for your applications to be able to have access to the complete set of data\non-chain, but it also means it will include spam tokens when querying with default settings."}),"\n",(0,a.jsxs)(t.p,{children:["To combat spam, we introduced ",(0,a.jsx)(t.code,{children:"metadataOptions"})," arguments which can be passed to Indexer RPC\ncalls to control the results returned."]}),"\n",(0,a.jsxs)(t.p,{children:['The Sequence Metadata service keeps track of contracts which are "verified" by checking popular\nsources like Coingecko, OpenSea, Sequence Builder (',(0,a.jsx)(t.a,{href:"https://sequence.build",children:"https://sequence.build"}),") and the Sequence Token\nDirectory (",(0,a.jsx)(t.a,{href:"https://github.com/0xsequence/token-directory",children:"https://github.com/0xsequence/token-directory"}),"). By calling the Indexer RPC methods with\n",(0,a.jsx)(t.code,{children:'"metadataOptions": { "verifiedOnly": true }'}),", any contract address which has not been verified, will\nbe omitted from the results. We recommend using this option all the time, but, the downside is\nif your project's contracts are unverified, then they will also be omitted from the results. To help\nwith this, your options are to get verified with one of the sources above, or in your RPC calls to pass\n",(0,a.jsx)(t.code,{children:'"metadataOptions": { "verifiedOnly": true, "includeContracts": ["0x631998e91476DA5B870D741192fc5Cbc55F5a52E", "0x8bb759bb68995343ff1e9d57ac85ff5c5fb79334"] }'}),"\nas an example."]})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},7279:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>r});var a=n(959);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);