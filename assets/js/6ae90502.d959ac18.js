"use strict";(self.webpackChunk_0xsequence_docs=self.webpackChunk_0xsequence_docs||[]).push([[1462],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(a),p=r,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||i;return a?n.createElement(m,o(o({ref:t},u),{},{components:a})):n.createElement(m,o({ref:t},u))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},6943:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={},o="Sequence - Wallet as a service",s={unversionedId:"waas/intro/intro",id:"waas/intro/intro",title:"Sequence - Wallet as a service",description:"Sequence WaaS (wallet as a service) enables the creation, management and usage of fully functional EVM compatible wallets. These wallets can be created on-demand for each user and allow you to integrate an application with an Ethereum compatible blockchain, while using familiar constructions like RPC APIs.",source:"@site/docs/10-waas/01-intro/01-intro.mdx",sourceDirName:"10-waas/01-intro",slug:"/waas/intro/",permalink:"/waas/intro/",draft:!1,editUrl:"https://github.com/0xsequence/docs/edit/master/docs/10-waas/01-intro/01-intro.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"sidebar",previous:{title:"Migrate to sequence.js v1.1.0",permalink:"/migrate-sequence-js-1-1-0"},next:{title:"Sequence WaaS Modes: An Introduction",permalink:"/waas/intro/modes"}},l={},c=[{value:"Architecture overview",id:"architecture-overview",level:2},{value:"Signer 1: PSS - Partner signer server",id:"signer-1-pss---partner-signer-server",level:3},{value:"Signer 2: Sequence Guard",id:"signer-2-sequence-guard",level:3},{value:"Threat model",id:"threat-model",level:2}],u={toc:c};function h(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"sequence---wallet-as-a-service"},"Sequence - Wallet as a service"),(0,r.kt)("p",null,"Sequence WaaS (wallet as a service) enables the creation, management and usage of fully functional EVM compatible wallets. These wallets can be created on-demand for each user and allow you to integrate an application with an Ethereum compatible blockchain, while using familiar constructions like RPC APIs."),(0,r.kt)("p",null,"Sequence WaaS offers real non-custodial wallets, and the system guarantees that each created wallet can only be accessed only with the consent of the owner of the wallet."),(0,r.kt)("h2",{id:"architecture-overview"},"Architecture overview"),(0,r.kt)("p",null,"Sequence WaaS wallets are native smart contract multisigs, the configuration of the multisig can be seen as a 2/2, both of which are required to sign in order to operate them; each one of the signers protects the wallet from a different facet of possible threats."),(0,r.kt)("h3",{id:"signer-1-pss---partner-signer-server"},"Signer 1: PSS - Partner signer server"),(0,r.kt)("p",null,"This service is hosted by the partner, it contains one of the two keys in the wallet. Its purpose is to protect the wallets against the Sequence WaaS API misbehaving. It achieves this by re-validating all API calls that were originally requested to the API."),(0,r.kt)("h3",{id:"signer-2-sequence-guard"},"Signer 2: Sequence Guard"),(0,r.kt)("p",null,"The Sequence Guard is hosted by Sequence, it contains the other key of the wallets. It's meant to protect the wallets against any case in which the WaaS API keys of the partner become compromised. It achieves this in two different ways:"),(0,r.kt)("p",null,"1 - Limits and allowlists: you can (from the development dashboard) configure what kind of actions are allowed, this means that the guard will only sign transactions within these constraints. For example, you can define that only NFT contract X can be called, and the guard will enforce that no other transactions can take place."),(0,r.kt)("p",null,"2 - Authenticating the user: the Sequence Guard will authenticate the user ",(0,r.kt)("strong",{parentName:"p"},"independently from the partner authentication"),", it performs this action either by using a 3rd party OAuth 2.0 id token (from Meta, Google, X, etc.) or by directly communicating with the user via email/phone number with an OTP code."),(0,r.kt)("h2",{id:"threat-model"},"Threat model"),(0,r.kt)("p",null,"With these safeguards in place wallets are ",(0,r.kt)("strong",{parentName:"p"},"safe")," against the following scenarios:"),(0,r.kt)("p",null,"1) Sequence.app backend is compromised, or guard keys are leaked: in this scenario, the PSS will refuse to sign, since it can't validate the correct origin of the WaaS API calls."),(0,r.kt)("p",null,"2) Partner backend is compromised, or PSS keys are leaked: in this scenario the Sequence guard protects the wallets, because it independently authenticates the user, an attacker in this scenario wouldn't be able to access any wallets."),(0,r.kt)("p",null,"The model also provides partial protection against the scenario:"),(0,r.kt)("p",null,"3) Partner frontend is compromised, or MIDM on the partner side: If an attacker were to be able to vulnerate the frontend of the partner, it could gain access to wallets at the time of login, but it cannot gain access to wallets of users who are currently inactive. This means that recovery from such a scenario is possible, with limited damage."))}h.isMDXComponent=!0}}]);