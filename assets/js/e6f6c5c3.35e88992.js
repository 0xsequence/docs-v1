"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4762],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=d(a),h=l,c=m["".concat(s,".").concat(h)]||m[h]||p[h]||i;return a?n.createElement(c,r(r({ref:t},u),{},{components:a})):n.createElement(c,r({ref:t},u))}));function h(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var d=2;d<i;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},74139:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(87462),l=(a(67294),a(3905));const i={},r="Modules & wallet update",o={unversionedId:"wallet-contracts/modules-and-updates",id:"wallet-contracts/modules-and-updates",title:"Modules & wallet update",description:"Sequence modules are the underlying program implementation of the wallets; wallets can change modules at runtime.",source:"@site/docs/wallet-contracts/05-modules-and-updates.mdx",sourceDirName:"wallet-contracts",slug:"/wallet-contracts/modules-and-updates",permalink:"/wallet-contracts/modules-and-updates",draft:!1,editUrl:"https://github.com/0xsequence/docs/edit/master/docs/wallet-contracts/05-modules-and-updates.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"sidebar",previous:{title:"Wallet Configuration",permalink:"/wallet-contracts/wallet-configuration"},next:{title:"MainModuleUpgradeable & configuration migration",permalink:"/wallet-contracts/main-module-upgradeable"}},s={},d=[{value:"Wallet implementation",id:"wallet-implementation",level:2},{value:"_updateConfiguration",id:"_updateconfiguration",level:3},{value:"Parameters:",id:"parameters",level:4},{value:"Reading current implementation",id:"reading-current-implementation",level:3},{value:"Wallet configuration validation",id:"wallet-configuration-validation",level:2},{value:"_isValidImage",id:"_isvalidimage",level:3},{value:"Parameters:",id:"parameters-1",level:4},{value:"Return Values:",id:"return-values",level:4},{value:"MainModuleUpgradeable",id:"mainmoduleupgradeable",level:2},{value:"<code>updateImageHash</code>",id:"updateimagehash",level:3},{value:"Parameters:",id:"parameters-2",level:4},{value:"First configuration update",id:"first-configuration-update",level:2},{value:"delegateCall: false",id:"delegatecall-false",level:4},{value:"revertOnError: true",id:"revertonerror-true",level:4},{value:"to: wallet",id:"to-wallet",level:4},{value:"value: ethers.constants.Zero",id:"value-ethersconstantszero",level:4},{value:"gasLimit: ethers.constants.Zero",id:"gaslimit-ethersconstantszero",level:4},{value:"Subsequent configuration updates",id:"subsequent-configuration-updates",level:3},{value:"Retrieving the current configuration",id:"retrieving-the-current-configuration",level:3},{value:"Retrieving the wallet configuration",id:"retrieving-the-wallet-configuration",level:4}],u={toc:d};function p(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"modules--wallet-update"},"Modules & wallet update"),(0,l.kt)("p",null,"Sequence modules are the underlying program implementation of the wallets; wallets can change modules at runtime."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModule")," is the initial module of every Sequence wallet; it differs from the other modules because it doesn't store the set of signers on contract storage; it uses the ",(0,l.kt)("a",{parentName:"p",href:"/wallet-contracts/wallet-factory#deploy"},"salt")," provided to the Factory contract."),(0,l.kt)("h2",{id:"wallet-implementation"},"Wallet implementation"),(0,l.kt)("p",null,"Sequence modules can be assigned to wallets either by the factory or by updating it after the initial deployment. Only one module can be assigned to a wallet at a time."),(0,l.kt)("h3",{id:"_updateconfiguration"},"_updateConfiguration"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"updateImplementation")," allows to update the underlying implementation of the wallet proxy. This implementation contains all the core code that defines the wallet's behaviour."),(0,l.kt)("admonition",{title:"Dangerous operation",type:"warning"},(0,l.kt)("p",{parentName:"admonition"},"Calling ",(0,l.kt)("inlineCode",{parentName:"p"},"updateImplementation")," with an invalid implementation will result in the corruption of the wallet."),(0,l.kt)("p",{parentName:"admonition"},"Corrupt wallets may lead to the loss of funds.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function updateImplementation(\n  address _implementation\n) external override onlySelf {\n")),(0,l.kt)("h4",{id:"parameters"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_implementation"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"Address of the new wallet implementation.")))),(0,l.kt)("p",null,"This method has the ",(0,l.kt)("inlineCode",{parentName:"p"},"onlySelf")," modifier, which means that it can only be called by the wallet itself using a self-referencing transaction. Calls to this method coming from other addresses, even if these addresses are signers of the wallet, will be rejected."),(0,l.kt)("h3",{id:"reading-current-implementation"},"Reading current implementation"),(0,l.kt)("p",null,"The wallet implementation is stored on the contract storage slot defined by the address of the wallet itself. Given that every wallet has a unique address, the implementation slot varies from wallet to wallet."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'import "ethers"\n\nconst address = "0x596af90cecdbf9a768886e771178fd5561dd27ab"\nconst provider = new ethers.providers.JsonRpcProvider("http://localhost:8545")\n\n// Read storage slot address(address)\nconst slot = await provider.getStorageAt(address, ethers.utils.defaultAbiCoder.encode([\'address\'], [address]))\n\n// Decode bytes32 as address value\nconst implementation = ethers.utils.defaultAbiCoder.decode([\'address\'], slot)[0]\n\nconsole.log(implementation)\n')),(0,l.kt)("h2",{id:"wallet-configuration-validation"},"Wallet configuration validation"),(0,l.kt)("admonition",{title:"Fixed configuration",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Signer's configuration on wallets using ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModule")," can't be changed. The only way to change the set of signers or threshold is by updating the module of the wallet.")),(0,l.kt)("p",null,"All sequence modules must implement the ",(0,l.kt)("inlineCode",{parentName:"p"},"ModuleAuth")," interface, this interface allows the rest of the module to validate signatures for the wallet. In the case of ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModule")," this interface is implemented as a counter-factual validation of hash passed to the factory during the contract wallet creation."),(0,l.kt)("h3",{id:"_isvalidimage"},"_isValidImage"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function _isValidImage(\n    bytes32 _imageHash\n  ) internal override view returns (bool _isValid)\n")),(0,l.kt)("p",null,"Validates if the provided ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," corresponds to the one configured in the wallet. This function is called internally to validate transaction and message signatures."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," is a hash of the wallet configuration, which contains the wallet's threshold, signers and weights."),(0,l.kt)("h4",{id:"parameters-1"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_imageHash"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:null},"Hash of wallet configuration to be validated.")))),(0,l.kt)("h4",{id:"return-values"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_isValid"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"True if the given ",(0,l.kt)("inlineCode",{parentName:"td"},"imageHash")," corresponds to the current wallet configuration.")))),(0,l.kt)("h2",{id:"mainmoduleupgradeable"},"MainModuleUpgradeable"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"MainModuleUpgradable")," is a module that mimics the behaviour of the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModule")," but allows the wallet configuration to be updated."),(0,l.kt)("h3",{id:"updateimagehash"},(0,l.kt)("inlineCode",{parentName:"h3"},"updateImageHash")),(0,l.kt)("p",null,"Updates the wallet ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash"),", this is the hash that defines the wallet configuration (signers, weights, threshold)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function updateImageHash(\n    bytes32 _imageHash\n  ) external override onlySelf {\n")),(0,l.kt)("h4",{id:"parameters-2"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"_imageHash"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:null},"Hash of the new configuration for the wallet.")))),(0,l.kt)("admonition",{title:"Unsanitized input",type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," is not validated, it is the responsibility of the caller to ensure that the hash is correct. Reasons for incorrect hashes include:"),(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},"The combined weight of the signers is below the threshold."),(0,l.kt)("li",{parentName:"ul"},"The signers are not valid addresses."),(0,l.kt)("li",{parentName:"ul"},"The signers are smart contract wallets without proper support for EIP-1271."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"imageHash")," doesn't correspond to any wallet configuration (may be a random string)."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"imageHash")," corresponds to an unknown wallet configuration.")),(0,l.kt)("p",{parentName:"admonition"},"In any of this cases the wallet will be ",(0,l.kt)("strong",{parentName:"p"},"rendered unusable"),".")),(0,l.kt)("p",null,"This method has the ",(0,l.kt)("inlineCode",{parentName:"p"},"onlySelf")," modifier, which means that it can only be called by the wallet itself using a self-referencing transaction. Calls to this method coming from other addresses, even if these addresses are signers of the wallet, will be rejected."),(0,l.kt)("h2",{id:"first-configuration-update"},"First configuration update"),(0,l.kt)("p",null,"When Sequence wallets are created, the factory contract doesn't call an ",(0,l.kt)("inlineCode",{parentName:"p"},"initialize")," function. The configuration is instead defined by the ",(0,l.kt)("inlineCode",{parentName:"p"},"salt")," provided to the factory, the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModule")," then checks the counterfactual validity of all signatures against the wallet address."),(0,l.kt)("p",null,"This means there is no direct way to update the configuration of a wallet while still using the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModule"),". Given that the first configuration update needs to also change the wallet implementation to the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModuleUpgradable"),", the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModule")," is updated to the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModuleUpgradable")," and the ",(0,l.kt)("inlineCode",{parentName:"p"},"updateImageHash")," method is called to update the wallet configuration."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const transactions = [\n  {\n    delegateCall: false,\n    revertOnError: true,\n    to: wallet,\n    data: walletInterface.encodeFunctionData(\n      walletInterface.getFunction('updateImplementation'), [this.context.mainModuleUpgradable]\n    ),\n    value: ethers.constants.Zero,\n    gasLimit: ethers.constants.Zero,\n  },\n  {\n    delegateCall: false,\n    revertOnError: true,\n    to: wallet,\n    data: mainModuleInterface.encodeFunctionData(\n      mainModuleInterface.getFunction('updateImageHash'), [newImageHash]\n    ),\n    value: ethers.constants.Zero,\n    gasLimit: ethers.constants.Zero,\n  }\n]\n")),(0,l.kt)("h4",{id:"delegatecall-false"},"delegateCall: false"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"delegateCall")," is used to extend the wallet functionality beyond what's allowed by the module. In this case the called methods are defined on the modules themselves, so there is no need to use ",(0,l.kt)("inlineCode",{parentName:"p"},"delegateCall"),"."),(0,l.kt)("h4",{id:"revertonerror-true"},"revertOnError: true"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"revertOnError")," is used to revert the whole transaction bundle if a transaction flagged by it fails. In this case the operation should be atomic given that a partial wallet configuration update ",(0,l.kt)("strong",{parentName:"p"},"will")," render the wallet unusable."),(0,l.kt)("h4",{id:"to-wallet"},"to: wallet"),(0,l.kt)("p",null,"The methods being called are defined on the wallet itself, but need to be called externally, so the ",(0,l.kt)("inlineCode",{parentName:"p"},"to")," address is the wallet itself."),(0,l.kt)("h4",{id:"value-ethersconstantszero"},"value: ethers.constants.Zero"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"value")," of the transaction is always zero, since the transaction is a self-referencing transaction and doesn't require transfering funds."),(0,l.kt)("h4",{id:"gaslimit-ethersconstantszero"},"gasLimit: ethers.constants.Zero"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"gasLimit")," of the transaction is always zero, since it represents an unlimited amount of gas."),(0,l.kt)("admonition",{title:"Dangerous operation",type:"warning"},(0,l.kt)("p",{parentName:"admonition"},"When the wallet is first updated to the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModuleUpgradable")," it doesn't have a valid ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," yet. It's imperative that the ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," is updated before the transaction bundle finishes executing.\nIf the ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," is not updated before the transaction bundle finishes executing, the wallet will be rendered unusable."),(0,l.kt)("p",{parentName:"admonition"},"For this reason the following considerations should be taken when updating the wallet for the first time:"),(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},"All transactions should be marked ",(0,l.kt)("inlineCode",{parentName:"li"},"revertOnError = true"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"updateImplementation")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"updateImageHash")," should both be declared on the same transaction bundle."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"gasLimit")," of both transactions should be set to unlimited (",(0,l.kt)("inlineCode",{parentName:"li"},"0"),")."))),(0,l.kt)("h3",{id:"subsequent-configuration-updates"},"Subsequent configuration updates"),(0,l.kt)("p",null,"Once the wallet is updated to the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModuleUpgradable")," it can be updated by calling the ",(0,l.kt)("inlineCode",{parentName:"p"},"updateImageHash")," method, without any additional transaction."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const transactions = [\n  {\n    delegateCall: false,\n    revertOnError: true,\n    to: wallet,\n    data: mainModuleInterface.encodeFunctionData(\n      mainModuleInterface.getFunction('updateImageHash'), [newImageHash]\n    ),\n    value: ethers.constants.Zero,\n    gasLimit: ethers.constants.Zero,\n  }\n]\n")),(0,l.kt)("h3",{id:"retrieving-the-current-configuration"},"Retrieving the current configuration"),(0,l.kt)("p",null,"If the wallet is updated to the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModuleUpgradable")," it can be queried for the current configuration by calling the ",(0,l.kt)("inlineCode",{parentName:"p"},"getImageHash")," method."),(0,l.kt)("p",null,"This method should return the wallet's current configuration hash, which can be compared to a list of known wallet configurations to find the correct one."),(0,l.kt)("h4",{id:"retrieving-the-wallet-configuration"},"Retrieving the wallet configuration"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," method returns ",(0,l.kt)("inlineCode",{parentName:"p"},"bytes32(0)")," if the wallet is not yet updated to the ",(0,l.kt)("inlineCode",{parentName:"p"},"MainModuleUpgradable"),".\nIn this case the wallet is in a counter-factual state and the ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," can't be directly queried."),(0,l.kt)("p",null,"This is also the case for non-deployed wallets."),(0,l.kt)("p",null,"To find the ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," of a non-deployed or non-updated wallet, a candidate known ",(0,l.kt)("inlineCode",{parentName:"p"},"imageHash")," needs to be compared against the wallet address."),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/wallet-contracts/wallet-configuration#compute-wallet-address"},"Compute wallet address"),"."))}p.isMDXComponent=!0}}]);