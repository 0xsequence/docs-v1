"use strict";(self.webpackChunk_0xsequence_docs=self.webpackChunk_0xsequence_docs||[]).push([[9358],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>f});var n=t(7294);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=n.createContext({}),c=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},d=function(e){var a=c(e.components);return n.createElement(o.Provider,{value:a},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},g=n.forwardRef((function(e,a){var t=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(t),g=i,f=u["".concat(o,".").concat(g)]||u[g]||p[g]||s;return t?n.createElement(f,r(r({ref:a},d),{},{components:t})):n.createElement(f,r({ref:a},d))}));function f(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var s=t.length,r=new Array(s);r[0]=g;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<s;c++)r[c]=t[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}g.displayName="MDXCreateElement"},5162:(e,a,t)=>{t.d(a,{Z:()=>r});var n=t(7294),i=t(6010);const s={tabItem:"tabItem_Ymn6"};function r(e){let{children:a,hidden:t,className:r}=e;return n.createElement("div",{role:"tabpanel",className:(0,i.Z)(s.tabItem,r),hidden:t},a)}},4866:(e,a,t)=>{t.d(a,{Z:()=>v});var n=t(7462),i=t(7294),s=t(6010),r=t(2466),l=t(6550),o=t(1980),c=t(7392),d=t(12);function u(e){return function(e){return i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:a}=e;return!!a&&"object"==typeof a&&"value"in a}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:a,label:t,attributes:n,default:i}}=e;return{value:a,label:t,attributes:n,default:i}}))}function p(e){const{values:a,children:t}=e;return(0,i.useMemo)((()=>{const e=a??u(t);return function(e){const a=(0,c.l)(e,((e,a)=>e.value===a.value));if(a.length>0)throw new Error(`Docusaurus error: Duplicate values "${a.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[a,t])}function g(e){let{value:a,tabValues:t}=e;return t.some((e=>e.value===a))}function f(e){let{queryString:a=!1,groupId:t}=e;const n=(0,l.k6)(),s=function(e){let{queryString:a=!1,groupId:t}=e;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:a,groupId:t});return[(0,o._X)(s),(0,i.useCallback)((e=>{if(!s)return;const a=new URLSearchParams(n.location.search);a.set(s,e),n.replace({...n.location,search:a.toString()})}),[s,n])]}function m(e){const{defaultValue:a,queryString:t=!1,groupId:n}=e,s=p(e),[r,l]=(0,i.useState)((()=>function(e){let{defaultValue:a,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!g({value:a,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${a}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return a}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:a,tabValues:s}))),[o,c]=f({queryString:t,groupId:n}),[u,m]=function(e){let{groupId:a}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(a),[n,s]=(0,d.Nk)(t);return[n,(0,i.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:n}),b=(()=>{const e=o??u;return g({value:e,tabValues:s})?e:null})();(0,i.useLayoutEffect)((()=>{b&&l(b)}),[b]);return{selectedValue:r,selectValue:(0,i.useCallback)((e=>{if(!g({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),m(e)}),[c,m,s]),tabValues:s}}var b=t(2389);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function k(e){let{className:a,block:t,selectedValue:l,selectValue:o,tabValues:c}=e;const d=[],{blockElementScrollPositionUntilNextRender:u}=(0,r.o5)(),p=e=>{const a=e.currentTarget,t=d.indexOf(a),n=c[t].value;n!==l&&(u(a),o(n))},g=e=>{let a=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;a=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;a=d[t]??d[d.length-1];break}}a?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},a)},c.map((e=>{let{value:a,label:t,attributes:r}=e;return i.createElement("li",(0,n.Z)({role:"tab",tabIndex:l===a?0:-1,"aria-selected":l===a,key:a,ref:e=>d.push(e),onKeyDown:g,onClick:p},r,{className:(0,s.Z)("tabs__item",h.tabItem,r?.className,{"tabs__item--active":l===a})}),t??a)})))}function y(e){let{lazy:a,children:t,selectedValue:n}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(a){const e=s.find((e=>e.props.value===n));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},s.map(((e,a)=>(0,i.cloneElement)(e,{key:a,hidden:e.props.value!==n}))))}function w(e){const a=m(e);return i.createElement("div",{className:(0,s.Z)("tabs-container",h.tabList)},i.createElement(k,(0,n.Z)({},e,a)),i.createElement(y,(0,n.Z)({},e,a)))}function v(e){const a=(0,b.Z)();return i.createElement(w,(0,n.Z)({key:String(a)},e))}},1793:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>o,default:()=>f,frontMatter:()=>l,metadata:()=>c,toc:()=>u});var n=t(7462),i=(t(7294),t(3905)),s=t(4866),r=t(5162);const l={},o="Signing & Verifying Messages",c={unversionedId:"wallet/guides/sign-message",id:"wallet/guides/sign-message",title:"Signing & Verifying Messages",description:"Signing Messages",source:"@site/docs/03-wallet/04-guides/03-sign-message.mdx",sourceDirName:"03-wallet/04-guides",slug:"/wallet/guides/sign-message",permalink:"/wallet/guides/sign-message",draft:!1,editUrl:"https://github.com/0xsequence/docs/edit/master/docs/03-wallet/04-guides/03-sign-message.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"sidebar",previous:{title:"Authenticate Users with Message Signature",permalink:"/wallet/guides/auth-address"},next:{title:"No-Wallet-Confirmation Signatures",permalink:"/wallet/guides/session-keys"}},d={},u=[{value:"Signing Messages",id:"signing-messages",level:2},{value:"Verifying Message Signatures",id:"verifying-message-signatures",level:2},{value:"Verifying Message Signatures (via Sequence API)",id:"verifying-message-signatures-via-sequence-api",level:2},{value:"Verifying message signature from any kind of wallet (ie. Metamask or Sequence)",id:"verifying-message-signature-from-any-kind-of-wallet-ie-metamask-or-sequence",level:3},{value:"Verifying ETHAuth proof upon connecting a Sequence Wallet",id:"verifying-ethauth-proof-upon-connecting-a-sequence-wallet",level:3},{value:"How does it work?",id:"how-does-it-work",level:2},{value:"Notes on Signature Validation with EIP1271 + EIP6492",id:"notes-on-signature-validation-with-eip1271--eip6492",level:3},{value:"Legacy non-EIP6492 Signing",id:"legacy-non-eip6492-signing",level:2}],p={toc:u},g="wrapper";function f(e){let{components:a,...t}=e;return(0,i.kt)(g,(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"signing--verifying-messages"},"Signing & Verifying Messages"),(0,i.kt)("h2",{id:"signing-messages"},"Signing Messages"),(0,i.kt)("p",null,"Sequence wallets are able to sign arbitrary messages. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"To request a user's signature of a simple message:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signer = wallet.getSigner()\nconst message = 'Hello World!'\n\nconst signature = await signer.signMessage(message)\nconsole.log(signature)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"To request a user's signature of a typed-data (",(0,i.kt)("a",{parentName:"strong",href:"https://eips.ethereum.org/EIPS/eip-712"},"EIP712"),") message:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const typedData: sequence.utils.TypedData = {\n  domain: {\n    name: 'Ether Mail',\n    version: '1',\n    chainId: await wallet.getChainId(),\n    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'\n  },\n  types: {\n    Person: [\n      { name: 'name', type: 'string' },\n      { name: 'wallet', type: 'address' }\n    ]\n  },\n  message: {\n    name: 'Bob',\n    wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB'\n  }\n}\n\nconst signer = wallet.getSigner()\n\nconst signature = await signer.signTypedData(typedData.domain, typedData.types, typedData.message)\nconsole.log(signature)\n")),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"verifying-message-signatures"},"Verifying Message Signatures"),(0,i.kt)("p",null,"Once you have a signature, you'll often want to verify the validity of the data\neither from your app or from your server. The Sequence SDKs make this easy to do\nfrom either your frontend or backend."),(0,i.kt)("p",null,"Given a message and signature, you can check if a particular wallet signed that message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Here we fetch the different parameters, but in practice you may have these values\n// encoded and passed separately.\nconst wallet = sequence.getWallet()\nconst provider = wallet.getProvider()\nconst walletAddress = wallet.getAddress()\nconst chainId = wallet.getChainId()\n\n// The sequence utils `isValidMessageSignature` method can validate signatures\n// from any kind of wallet (ie. EOA or Smart Wallet) which includes Metamask, Coinbase,\n// and Sequence.\nconst isValid = await wallet.utils.isValidMessageSignature(\n  walletAddress,\n  message,\n  signature,\n  chainId\n)\n\nconsole.log(isValid)\n")),(0,i.kt)("admonition",{title:"Sequence is a Smart Contract based account",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"These signatures are by default encoded using EIP-6492, see ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-6492"},"https://eips.ethereum.org/EIPS/eip-6492"),"."),(0,i.kt)("p",{parentName:"admonition"},"This means that the signatures can be verified using the standard process defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"UniversalVerified")," contract on EIP-6492."),(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wallet.utils.isValidMessageSignature")," implements EIP-6492 verification, it can be used to verify signatures from any kind of wallet.")),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"verifying-message-signatures-via-sequence-api"},"Verifying Message Signatures (via Sequence API)"),(0,i.kt)("p",null,"The Sequence API also offers the convenience to verify any wallet message signature\nby making a simple remote API call."),(0,i.kt)("p",null,"The Sequence API (",(0,i.kt)("a",{parentName:"p",href:"https://api.sequence.app"},"https://api.sequence.app"),") supports the following RPC methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/rpc/API/IsValidMessageSignature")," -- verifying a simple text message signature"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/rpc/API/IsValidTypedDataSignature")," -- verifying a EIP712 typed data object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/rpc/API/IsValidSignature")," -- verifying an arbitrary message digest"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/rpc/API/IsValidETHAuthProof")," -- verifying an ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/0xsequence/ethauth.js"},"ETHAuth")," proof")),(0,i.kt)("p",null,"The most common methods are ",(0,i.kt)("inlineCode",{parentName:"p"},"IsValidMessageSignature")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IsValidETHAuthProof"),". "),(0,i.kt)("h3",{id:"verifying-message-signature-from-any-kind-of-wallet-ie-metamask-or-sequence"},"Verifying message signature from any kind of wallet (ie. Metamask or Sequence)"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Sequence API ",(0,i.kt)("inlineCode",{parentName:"em"},"IsValidMessageSignature")," Method:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Request: POST ",(0,i.kt)("a",{parentName:"li",href:"https://api.sequence.app/rpc/API/IsValidMessageSignature"},"https://api.sequence.app/rpc/API/IsValidMessageSignature")),(0,i.kt)("li",{parentName:"ul"},"Content-Type: application/json"),(0,i.kt)("li",{parentName:"ul"},"Body (in JSON):",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chainId"),' (string) -- the chain id of the signature, ie. "1" or "mainnet", or "137" or "polygon", etc'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"walletAddress")," (string) -- the wallet address"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"message")," (string) -- the message in utf8 text encoding"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signature")," (string) -- the signature in hex encoding")))),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"IsValidMessageSignature")," example usage:")),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"curl",label:"curl",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash wrap",metastring:"class=wrap"},'curl -X POST -H "Content-Type: application/json" https://api.sequence.app/rpc/API/IsValidMessageSignature -d \'{ "chainId": "polygon", "walletAddress": "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1", "message": "Hi, please sign this message", "signature": "0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d0001000183d971056b1eca1bcc7289b9a6926677c5b07db4197925346367f61f2d09c732760719a91722acee0b24826f412cb69bd2125e48f231705a5be33d1f5523f9291c020101c50adeadb7fe15bee45dcb820610cdedcd314eb0030002f19915df00d669708608502d3011a09948b32674d6e443202a2ba884a4dcd26c2624ff33a8ee9836cc3ca2fbb8d3aa43382047b73d21646cb66cc2916076c1331c02" }\'\n'))),(0,i.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Works in both a Webapp (browser) or Node.js:\nimport { sequence } from '0xsequence'\n\nconst chainId = 'polygon'\nconst walletAddress = '0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1'\nconst message = 'Hi, please sign this message'\nconst signature = '0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d0001000183d971056b1eca1bcc7289b9a6926677c5b07db4197925346367f61f2d09c732760719a91722acee0b24826f412cb69bd2125e48f231705a5be33d1f5523f9291c020101c50adeadb7fe15bee45dcb820610cdedcd314eb0030002f19915df00d669708608502d3011a09948b32674d6e443202a2ba884a4dcd26c2624ff33a8ee9836cc3ca2fbb8d3aa43382047b73d21646cb66cc2916076c1331c02'\n\nconst api = new sequence.api.SequenceAPIClient('https://api.sequence.app')\nconst { isValid } = await api.isValidMessageSignature({\n  chainId, walletAddress, message, signature\n})\nconsole.log(isValid) // true\n"))),(0,i.kt)(r.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "context"\n    "fmt"\n    "log"\n    "net/http"\n\n    "github.com/0xsequence/go-sequence/api"\n)\n\nfunc ValidateMessageSignature() {\n    seqAPI := api.NewAPIClient("https://api.sequence.app", http.DefaultClient)\n\n    chainID := "polygon"\n    walletAddress := "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1"\n\n    // NOTE: you can also pass the message in EIP191 format as well. If you do not pass\n    // the EIP191 prefix, it will automatically be added at the time of validation.\n    // message := fmt.Sprintf("\\x19Ethereum Signed Message:\\n%d%s", len(message), message)\n    message := "Hi, please sign this message"\n\n    signature := "0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d0001000183d971056b1eca1bcc7289b9a6926677c5b07db4197925346367f61f2d09c732760719a91722acee0b24826f412cb69bd2125e48f231705a5be33d1f5523f9291c020101c50adeadb7fe15bee45dcb820610cdedcd314eb0030002f19915df00d669708608502d3011a09948b32674d6e443202a2ba884a4dcd26c2624ff33a8ee9836cc3ca2fbb8d3aa43382047b73d21646cb66cc2916076c1331c02"\n\n    isValid, err := seqAPI.IsValidMessageSignature(context.Background(), chainID, walletAddress, message, signature)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("isValid?", isValid)\n}\n'))),(0,i.kt)(r.Z,{value:"other",label:"Other",mdxType:"TabItem"},(0,i.kt)("p",null,"Please ",(0,i.kt)("a",{parentName:"p",href:"/support"},"contact our team")," for assistance with integrations to another target."))),(0,i.kt)("br",null),(0,i.kt)("h3",{id:"verifying-ethauth-proof-upon-connecting-a-sequence-wallet"},"Verifying ETHAuth proof upon connecting a Sequence Wallet"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Sequence API ",(0,i.kt)("inlineCode",{parentName:"em"},"IsValidETHAuthProof")," Method:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Request: POST ",(0,i.kt)("a",{parentName:"li",href:"https://api.sequence.app/rpc/API/IsValidETHAuthProof"},"https://api.sequence.app/rpc/API/IsValidETHAuthProof")),(0,i.kt)("li",{parentName:"ul"},"Content-Type: application/json"),(0,i.kt)("li",{parentName:"ul"},"Body (in JSON):",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chainId"),' (string) -- the chain id of the signature, ie. "1" or "mainnet", or "137" or "polygon", etc'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"walletAddress")," (string) -- the wallet address"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ethAuthProofString")," (string) -- the ETHAuth encoded signature")))),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"IsValidETHAuthProof")," example usage:")),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"curl",label:"curl",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash wrap",metastring:"class=wrap"},'curl -X POST -H "Content-Type: application/json" https://api.sequence.app/rpc/API/IsValidETHAuthProof -d \'{"chainId":"polygon", "walletAddress":"0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1","ethAuthProofString": "eth.0x2fa0b551fdfa31a4471c1c52206fdb448ad997d1.eyJhcHAiOiJEZW1vIERhcHAiLCJpYXQiOjAsImV4cCI6MTY2MDIzMTAyOCwidiI6IjEiLCJvZ24iOiJodHRwOi8vbG9jYWxob3N0OjQwMDAifQ.0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d00010001f7dad5ade840bb961cbab889d731bbc080bb4c36fc090435e82fe78e3c152b671505ad544adb562cc25a5933cd06c9108e239a52a82ba797c3d3522645c69cd81b020101c50adeadb7fe15bee45dcb820610cdedcd314eb003000274164fb33c93b4384582c54c30d9a1e2ef219063d03084005edc1da853af2f1f2e67275dbb6ef945d04600b6dd83cfd997cc9ae4173ea61b0c5cc0808fb196681b02"}\' \n'))),(0,i.kt)(r.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Works in both a Webapp (browser) or Node.js:\nimport { sequence } from '0xsequence'\n\nconst chainId = 'polygon'\nconst walletAddress = '0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1'\nconst ethAuthProofString = 'eth.0x2fa0b551fdfa31a4471c1c52206fdb448ad997d1.eyJhcHAiOiJEZW1vIERhcHAiLCJpYXQiOjAsImV4cCI6MTY2MDIzMTAyOCwidiI6IjEiLCJvZ24iOiJodHRwOi8vbG9jYWxob3N0OjQwMDAifQ.0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d00010001f7dad5ade840bb961cbab889d731bbc080bb4c36fc090435e82fe78e3c152b671505ad544adb562cc25a5933cd06c9108e239a52a82ba797c3d3522645c69cd81b020101c50adeadb7fe15bee45dcb820610cdedcd314eb003000274164fb33c93b4384582c54c30d9a1e2ef219063d03084005edc1da853af2f1f2e67275dbb6ef945d04600b6dd83cfd997cc9ae4173ea61b0c5cc0808fb196681b02'\n\nconst api = new sequence.api.SequenceAPIClient('https://api.sequence.app')\nconst { isValid } = await api.isValidETHAuthProof({\n  chainId: chainId, walletAddress: walletAddress, ethAuthProofString: ethAuthProofString\n})\nconsole.log(isValid) // true\n"))),(0,i.kt)(r.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "context"\n    "fmt"\n    "log"\n    "net/http"\n\n    "github.com/0xsequence/go-sequence/api"\n)\n\nfunc ValidateETHAuth() {\n    seqAPI := api.NewAPIClient("https://api.sequence.app", http.DefaultClient)\n\n    chainID := "polygon"\n    walletAddress := "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1"\n    ethAuthProofString := "eth.0x2fa0b551fdfa31a4471c1c52206fdb448ad997d1.eyJhcHAiOiJEZW1vIERhcHAiLCJpYXQiOjAsImV4cCI6MTY2MDIzMTAyOCwidiI6IjEiLCJvZ24iOiJodHRwOi8vbG9jYWxob3N0OjQwMDAifQ.0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d00010001f7dad5ade840bb961cbab889d731bbc080bb4c36fc090435e82fe78e3c152b671505ad544adb562cc25a5933cd06c9108e239a52a82ba797c3d3522645c69cd81b020101c50adeadb7fe15bee45dcb820610cdedcd314eb003000274164fb33c93b4384582c54c30d9a1e2ef219063d03084005edc1da853af2f1f2e67275dbb6ef945d04600b6dd83cfd997cc9ae4173ea61b0c5cc0808fb196681b02"\n\n    isValid, err := seqAPI.IsValidETHAuthProof(context.Background(), chainID, walletAddress, ethAuthProofString)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("isValid?", isValid)\n}\n'))),(0,i.kt)(r.Z,{value:"other",label:"Other",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"")))),(0,i.kt)("br",null),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,i.kt)("h3",{id:"notes-on-signature-validation-with-eip1271--eip6492"},"Notes on Signature Validation with EIP1271 + EIP6492"),(0,i.kt)("p",null,"Smart Wallets like Sequence rely on the ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP1271")," standard for signature validation."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP1271")," is a single function on a contract defined as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function isValidSignature(\n  bytes32 _hash, \n  bytes memory _signature\n) public view returns (bytes4 magicValue)\n")),(0,i.kt)("p",null,"The first ",(0,i.kt)("inlineCode",{parentName:"p"},"_hash")," argument accepts the hash of the message digest, and the second argument ",(0,i.kt)("inlineCode",{parentName:"p"},"_signature"),"\nis the signed payload returned by the wallet upon signing. "),(0,i.kt)("p",null,"Additionally, Smart Wallets don't always deploy a contract onchain every time a new wallet is created.\nInstead, they compute the wallet address deterministically, and the wallet is only deployed when a transaction needs to be made."),(0,i.kt)("p",null,"In this case, we can't use the ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP1271")," function directly, because the wallet contract doesn't exist yet.\nInstead, we use the ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-6492"},"EIP-6492")," standard, which defined a method for bootstrapping the wallet\ncontract and calling the ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP1271")," function, in a single operation."),(0,i.kt)("p",null,"For Javascript/Typescript signature verification, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"0xsequence")," utility functions like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { 0xsequence } from '0xsequence'\n\nconst wallet = sequence.getWallet()\n\nconst isValid = await wallet.utils.isValidSignature(\n  walletAddress,\n  digest,\n  signature,\n  chainId\n)\n\nconsole.log(isValid) // returns true/false\n")),(0,i.kt)("p",null,"Additionally you can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"wallet.utils.isValidMessageSignature")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"wallet.utils.isValidTypedDataSignature"),"\nwhich are just syntactic sugar for ",(0,i.kt)("inlineCode",{parentName:"p"},"wallet.utils.isValidSignature"),"."),(0,i.kt)("p",null,"As well, for convenience the signature validation functions above support verifying EOA or Smart Wallet signatures.\nThis allows you to use a single code path in your Dapp to verify any kind of signature and support multiple wallets at\nthe same time, like Metamask, Coinbase, Sequence, WalletConnect, Argent, Rainbow, etc. -- all Ethereum compatible wallets, EOA\nor Smart Wallets, will ",(0,i.kt)("em",{parentName:"p"},"just work"),"."),(0,i.kt)("h2",{id:"legacy-non-eip6492-signing"},"Legacy non-EIP6492 Signing"),(0,i.kt)("p",null,"By default, all the signing methods will generate ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-6492"},"EIP-6492")," encoded signatures.\nThis avoids the need to deploy the wallet onchain before being able to validate the signature, and is the recommended way to sign messages."),(0,i.kt)("p",null,"However, if you need to generate legacy non-EIP6492 signatures, you can do so by setting the last argument of the signing methods to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signer = wallet.getSigner()\nconst message = 'Hello World!'\n\nconst signature = await signer.signMessage(message, { eip6492: false })\nconsole.log(signature)\n")),(0,i.kt)("p",null,"These legacy signatures can be validated using the ",(0,i.kt)("inlineCode",{parentName:"p"},"wallet.utils.isValidSignature method"),", but they can also be validated using\nthe isValidSignature method defined on the wallet contract, as specified by the ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"EIP1271")," standard."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Notice that signing non-EIP6492 signatures requires the wallet to be deployed onchain, and thus the user will be prompted\nto deploy the wallet onchain before being able to sign the message. If the network has fees (like Ethereum), the user will\nalso be prompted to pay the transaction fees.")))}f.isMDXComponent=!0}}]);