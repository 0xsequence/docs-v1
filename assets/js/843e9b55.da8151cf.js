"use strict";(self.webpackChunk_0xsequence_docs=self.webpackChunk_0xsequence_docs||[]).push([[1587],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(n),p=r,h=d["".concat(l,".").concat(p)]||d[p]||g[p]||i;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8176:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={},s="Signature Encoding",o={unversionedId:"wallet/wallet-contracts/signature-encoding",id:"wallet/wallet-contracts/signature-encoding",title:"Signature Encoding",description:"Sequence Wallets support ERC-1271 Standard Contract Signature Verification to allow signing of transactions and messages.",source:"@site/docs/03-wallet/10-wallet-contracts/08-signature-encoding.mdx",sourceDirName:"03-wallet/10-wallet-contracts",slug:"/wallet/wallet-contracts/signature-encoding",permalink:"/wallet/wallet-contracts/signature-encoding",draft:!1,editUrl:"https://github.com/0xsequence/docs/edit/master/docs/03-wallet/10-wallet-contracts/08-signature-encoding.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"sidebar",previous:{title:"Transaction encoding",permalink:"/wallet/wallet-contracts/transaction-encoding"},next:{title:"Nested Transaction Batching",permalink:"/wallet/wallet-contracts/nested-transaction-batching"}},l={},c=[{value:"ERC-191 Ethereum Signed Data",id:"erc-191-ethereum-signed-data",level:2},{value:"ERC-712 Structured Data Signatures",id:"erc-712-structured-data-signatures",level:2},{value:"Verification",id:"verification",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"signature-encoding"},"Signature Encoding"),(0,r.kt)("p",null,"Sequence Wallets support ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"ERC-1271 Standard Contract Signature Verification")," to allow signing of transactions and messages."),(0,r.kt)("h2",{id:"erc-191-ethereum-signed-data"},"ERC-191 Ethereum Signed Data"),(0,r.kt)("p",null,"Messages encoded with as ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-191"},"ERC-191 Ethereum Signed Data")," are able to be created and signed as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Wallet } from \'@0xsequence/wallet\'\n\n// Construct your Sequence Wallet (out of scope for this section)\nconst wallet: Wallet\n\nconst message = "Hello, World!"\n\nconst prefixedMessage = "\\x19Ethereum Signed Message:\\n" + len(message) + message\nconst signature = await wallet.signMessage(prefixedMessage)\n')),(0,r.kt)("p",null,"The above will iterate through local, signing the message. If the threshold is reached, the signature is returned.\nOtherwise the library will iterate through the remote signers as well.\nThe resulting signatures are joined and encoded as a hex string."),(0,r.kt)("h2",{id:"erc-712-structured-data-signatures"},"ERC-712 Structured Data Signatures"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-712"},"ERC-712 Structured Data")," can also be signed in a similar fashion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Wallet } from '@0xsequence/wallet'\nimport { encodeTypedDataDigest } from '@0xsequence/utils'\n\n// Construct your Sequence Wallet (out of scope for this section)\nconst wallet: Wallet\n\n// Encode the typed data\nconst chainId = 1\nconst typedData = {\n    types: {\n        Person: [\n            { name: 'name', type: 'string' },\n            { name: 'wallet', type: 'address' },\n            { name: 'count', type: 'uint8' }\n        ]\n    },\n    primaryType: 'Person' as const,\n    domain: {\n        name: 'Ether Mail',\n        version: '1',\n        chainId: chainId,\n        verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'\n    },\n    message: {\n        name: 'Bob',\n        wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n        count: 4\n    }\n} \nconst hashedData = encodeTypedDataDigest(typedData)\n\nconst signature = await wallet.signMessage(hashedData)\n")),(0,r.kt)("p",null,"The above will iterate through local, signing the message. If the threshold is reached, the signature is returned.\nOtherwise the library will iterate through the remote signers as well.\nThe resulting signatures are joined and encoded as a hex string."),(0,r.kt)("h2",{id:"verification"},"Verification"),(0,r.kt)("p",null,"The signature can be verified by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"isValidSignature")," method on the wallet."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol"},'  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\n   *   > The bytes4 magic value to return when signature is valid is 0x1626ba7e : bytes4(keccak256("isValidSignature(bytes32,bytes)"))\n   * @param _hash       keccak256 hash that was signed\n   * @param _signatures Signature byte array associated with _data.\n   *                    Encoded as abi.encode(Signature[], Configs)\n   * @return magicValue Magic value 0x1626ba7e if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signatures\n  ) public override virtual view returns (bytes4) {\n    // Validate signatures\n    (bool isValid,) = _signatureValidation(_hash, _signatures);\n    if (isValid) {\n      return SELECTOR_ERC1271_BYTES32_BYTES;\n    }\n\n    return bytes4(0);\n  }\n')),(0,r.kt)("p",null,"This will iterate through the combined signatures and validate that the resulting signature breaches the wallet's threshold."))}d.isMDXComponent=!0}}]);