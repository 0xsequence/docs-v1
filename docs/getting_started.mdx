---
sidebar_position: 2
slug: getting-started
---

# Getting Started

Get started with Sequence with just a few lines of code, follow along below.

## Install

First, install the [0xsequence](https://www.npmjs.com/package/0xsequence) package from NPM:

```shell
yarn install 0xsequence
```

or

```shell
npm install 0xsequence
```

You can find the source of the `0xsequence` package on [Github](https://github.com/0xsequence/sequence.js).


## Connect your wallet

**Connecting to Ethereum Mainnet:**

```ts
import { sequence } from '0xsequence'

const wallet = new sequence.Wallet('mainnet')
```

**Connecting to Polygon:**
```ts
import { sequence } from '0xsequence'

const wallet = new sequence.Wallet('polygon')
```

## Get the wallet address

```ts
const walletAddress = await wallet.getAddress()

console.log(walletAddress)
// # => '0xabcd....'
```

## Open the wallet from your dapp

```ts
wallet.openWallet()
```

## Get the blockchain network ID

You can use a variety of methods to query the chain ID which the wallet is presently
connected to.

```ts
console.log('chainId:', await wallet.getChainId())

const provider = wallet.getProvider()
console.log('provider.getChainId()', await provider.getChainId())

const signer = wallet.getSigner()
console.log('signer.getChainId()', await signer.getChainId())
```


## Sign & verify a message

```ts
// Get the wallet signer instance
const signer = wallet.getSigner()

// Prepare the message string
const message = `I've been to Web3 & back again :D`

// Sign the message
const signedMessage = await signer.signMessage(message)
console.log('message signature:', signedMessage)

// Validate the signed message
const isValid = await wallet.commands.isValidMessageSignature(
  await wallet.getAddress(),
  message,
  signedMessage,
  await signer.getChainId()
)

console.log('isValid?', isValid)
if (!isValid) throw new Error('signature is invalid')
```


## Sending an ERC-20 token

Let's now send some USDC tokens to another wallet address on the network.

```ts
// Part of the ERC20 ABI, so we can encode a `transfer` call
const ERC_20_ABI = [
  {
    constant: false,
    inputs: [
      {
        internalType: 'address',
        name: 'recipient',
        type: 'address'
      },
      {
        internalType: 'uint256',
        name: 'amount',
        type: 'uint256'
      }
    ],
    name: 'transfer',
    outputs: [
      {
        internalType: 'bool',
        name: '',
        type: 'bool'
      }
    ],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function'
  }
]

// Get the wallet signer interface
const signer = wallet.getSigner()

// Sending to a random address
const recipientAddress = ethers.Wallet.createRandom().address

// Sending 1.50 USDC, note USDC has 6 decimal places
const amount = ethers.utils.parseUnits('1.50', 6)

// Make the smart contract call to the USDC contract. Below is the USDC smart contract address
// on the Polygon network.
const usdcContractAddress = '0x2791bca1f2de4661ed88a30c99a7a9449aa84174'

const tx: sequence.transactions.Transaction = {
  to: usdcContractAddress,
  data: new ethers.utils.Interface(ERC_20_ABI).encodeFunctionData('transfer', [recipientAddress, amount.toHexString()])
}

// Send the transaction to the blockchain :D
const txnResp = await signer.sendTransaction(tx)

// Wait for the transaction to be mined by the network
await txnResp.wait()

// We're done, print the transaction hash, and open it up in your block explorer
console.log('transaction hash:', txnResp.hash)
```
