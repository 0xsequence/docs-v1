# Mint a Collectible using a Gasless Serverless Relayer

Time to complete: 15-30 minutes

The Sequence Relayer can be implemented on a severless [Cloudflare](https://cloudflare.com/) worker so a game or app user interaction is seamless without a confirmation signature or gas payment. You'll also benefit from not having to be worried about transaction speed, throughput and re-orgs by the relayer, and experience automatic scaling with cloudflare.

The following steps will guide you through how to build your technology in 4 steps:

1. [Setup Cloudflare environment with wrangler cli & deploy a test](/relayer/mint-collectible-severless#1-setup-cloudflare-environment-with-wrangler-cli--deploy-a-test)
2. [Write smart contract & deploy / sponsor with Builder](/relayer/mint-collectible-severless#2-write-smart-contract--deploy--sponsor-with-builder)
3. [Use EthAuthProof to prevent EOA DDoS](relayer/mint-collectible-severless#3-use-ethauthproof-to-prevent-eoa-ddos)
4. [Deploy & mint a collectible to wallet](relayer/mint-collectible-severless#4-deploy--mint-a-collectible-to-wallet)

The result, a secure API with the following specs:
* HTTPS GET: returns blockNumber
* HTTPS POST(proof, address): mints a collectible & returns transaction hash

## 1. Setup Cloudflare environment with wrangler cli & deploy a test

In order to create the project from scratch, first create a project with `mkdir`, `cd` into the project, and run `pnpm init` to create a `package.json`.

Next, make sure wrangler cli is installed in your project and set the `wrangler` keyword as an alias in your local bash session.

```
$ pnpm install wrangler --save-dev
$ alias wrangler='./node_modules/.bin/wrangler'
```

Create an account on the [Cloudflare site](https://cloudflare.com/) and perform a login step to login to your cloudflare dashboard to connect the Cloudflare platform to your local development environment.

```
$ wrangler login
```

Once logged in, initialize the project in the directory by accepting one of the randomly generated project folder names provided that you like, and follow the prompts to initialize your git tracked typescript `"Hello World" Worker` application. 

```
$ wrangler init
```

To complete this step, you should press enter 4 times after `wrangler init` with the last step answered as `No` to decline deployment.

This will clone down a starter repository that can be used to deploy code to the cloud.

#### Deploy Test

Finally, `cd` into the randomly generated project folder, and perform a `wrangler deploy` command. 

This should print a URL, which you can enter in the browser the URL `https://<app>.<account>.workers.dev` to view the `Hello World!` result.

## 2. Write a smart contract with Foundry & deploy / sponsor with Builder

Next, install Foundry with the following command so you can use the `forge` cli tool

```
$ curl -L https://foundry.paradigm.xyz | bash
```

Then, go up a directory from the perspective of the cloudflare worker files and create a new folder called `contracts` with `mkdir contracts` and enter the directory with `cd contracts`. Generate a template project and install the dependencies with the following command:

```
$ forge init && pnpm init && pnpm install @openzeppelin/contracts
```

So your project structure should look something like this:

```
.
├── cloudflare
│   ├── <project_name>
│   ├── node_modules
│   ├── package.json
│   └── pnpm-lock.yaml
└── contracts
    ├── foundry.toml
    ├── lib
    ├── node_modules
    ├── package.json
    ├── pnpm-lock.yaml
    ├── README.md
    ├── script
    ├── src
    └── test

```

Update the `foundry.toml` file to include the `node_modules` folder, so it looks like this:

```
[profile.default]
src = "src"
out = "out"
libs = ["lib", "node_modules"]
```

And now you're ready to write your contract. Here is a recommended contract that adds a few features like: only being able to mint using the relayer, the ability to turn on and off the mint, and an allowable contract owner with certain privileges.

```sol
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

contract Demo is ERC1155 {
    bool public minting;
    address public relayerAddress;
    address public ownerAddress;

    modifier onlyRelayer(){
        require(msg.sender == relayerAddress);
        _;
    }

    modifier onlyOwner(){
        require(msg.sender == ownerAddress);
        _;
    }

    constructor(address _relayerAddress) ERC1155("https://<your_metadata>/{id}.json") {
        relayerAddress = _relayerAddress;
        ownerAddress = msg.sender;
        minting = true;
    }

    function mint(uint _tokenID, address collector) onlyRelayer external {
        require(minting, "contract not minting");
        _mint(collector, _tokenID, 1, "");
    }

    function setMinting(bool _state) onlyOwner external {
        minting = _state;
    }
}
```

Rename the contract file to your choosing, for example: `mv src/Counter.sol src/Demo.sol` and delete the tests folder for now with `rm -rf test`

Then compile your code with the command `forge build` and follow the steps below to upload and deploy your contract in the [Sequence Builder](https://sequence.build).

#### Upload contract ABI to Builder

Access the contracts page once you've [created a project](https://www.youtube.com/watch?v=UAHxmO27KrA&list=PLN_CsIpJBRiiJ7MAKrWSXj1oxWTJfiEir&index=1) and select `+ View more contracts`

![contract page in builder](/img/relayer/contracts_page.png)

And select `+ Upload Source`

![view more options](/img/relayer/view_more_options.png)

Finally, name your contract and upload your ABI file generated locally before deploying your contract with `Upload Contract Source` and completing the onchain transaction to deploy to your selected network.

The ABI for upload should be located in: `your_project/contracts/out/Demo.sol/Demo.json`

![contract source](/img/relayer/contract_source.png)

Once you've completed the steps to upload, you'll be asked to input the `contract name` and `_relayerAddress` in the constructor.

![deploy contract with relayer address](/img/relayer/deploy_contract_with_relayer.png)

In order to know what the relayer address you are working with is, one must first print locally the account address produced from an EOA wallet private key using the following code snippet:

```ts
import { Session } from '@0xsequence/auth'
import { ethers } from 'ethers';

(() => {

	// Generate a new EOA
	// const wallet = ethers.Wallet.createRandom()
  	// const privateKey = wallet.privateKey

	// Or, use an existing EOA private key
	const privateKey = ''
	const provider = new ethers.providers.JsonRpcProvider('https://nodes.sequence.app/arbitrum-nova')

	// Create your server EOA
	const walletEOA = new ethers.Wallet(privateKey, provider)

	// Open a Sequence session, this will find or create
	// a Sequence wallet controlled by your server EOA
	const session = await Session.singleSigner({
		signer: walletEOA
	})

	const signer = session.account.getSigner(42170)

	console.log(`Your wallet address: ${signer.account.address}`)

})()
```

Finally, once you have your relayer address, input it into the contructor, sign the transaction and deploy. You'll find in the contracts page your contract address you'll need in order to send transactions to in the code, and, setup gas sponsorship of transactions using the following [video](https://www.youtube.com/watch?v=tDn4nd9Mi-c).

:::info Helpful tip when deploying using a Sequence Wallet
If you don't have any coin in your sequence wallet to pay for your transaction, you can sponsor your wallet address with a credit card in the [Sequence Builder](https://sequence.build). This allows all transactions from your wallet on a specific network to be free.
:::

## 3. Use EthAuthProof to prevent EOA DDoS

Now that we have a contract deployed, we can return to the cloudflare worker directory and project, and install `ethers` and `0xsequence` to get access to sequence APIs in order to perform a proof validation that the request is coming from a trusted source, a sequence wallet.

```
$ pnpm install 0xsequence ethers@5.7.2
```

Then, we have to add a type of middleware, after we check if it's a POST or GET request. If it's a POST request, verify that the passed in `proofString` and `address` are valid.  

The code scaffold placed into `src/index.ts` would look like this, with `callContract` and `getBlockNumber` mocked out, using the mentioned verification step of calling `verify` before any contract call.

```ts
import { sequence } from '0xsequence'
import { ethers } from 'ethers'

export interface Env {
	PKEY: string
}

// use the sequence api to verify proof came from a sequence wallet
const verify = async (chainId: string, walletAddress: string, ethAuthProofString: string): Promise<Boolean> => {
	const api = new sequence.api.SequenceAPIClient('https://api.sequence.app')
	const { isValid } = await api.isValidETHAuthProof({
		chainId, walletAddress, ethAuthProofString
	})
	return isValid
}

async function handleRequest(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
	if (env.PKEY === undefined || env.PKEY === '') {
		console.log('ooops! check your wranger.toml config to set your PKEY')
	}

	// POST request
	if (request.method === "POST") {
		// parse the request body as JSON
		const body = await request.json();
		const { proof, address, tokenId }: any = body;
		try {
			// check that the proof is valid
			if(await verify('polygon', address, proof)){
				try{
					// mocked call
					const res = await callContract(request, env, address, tokenId)
					return new Response(`${res.hash}`, { status: 200 })
				} catch (err: any) {
					console.log(err)
					return new Response(`Something went wrong: ${JSON.stringify(err)}`, { status: 400 })
				}
			} else {
				return new Response(`Unauthorized`, { status: 401 })
			}
		} catch(err: any){
			return new Response(`Unauthorized ${JSON.stringify(err)}`, { status: 401 })
		}
	} 
	// GET request
	else {
		try {
			// mocked call
			const res = await getBlockNumber(request)
			return new Response(`Block Number: ${res}`)
		} catch(err: any){
			return new Response(`Something went wrong: ${JSON.stringify(err)}`, { status: 400 })
		}
	}
}

const getBlockNumber = async (request: Request): Promise<number> => {
	return 0
}

const callContract = async (request: Request, env: Env, address: string, tokenId: number): Promise<ethers.providers.TransactionResponse> => {
	return { hash: "0x" } as any
}

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext) {
		// Process the request and create a response
		const response = await handleRequest(request, env, ctx);

		// Set CORS headers
		response.headers.set("Access-Control-Allow-Origin", "*");
		response.headers.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
		response.headers.set("Access-Control-Allow-Headers", "Content-Type");

		// return response
		return response;
	}
};
```

#### Implement window object in wrangler template

It should be noted, if you try to deploy this you'll get a missing `window` object required by the web3 modules. 

To prevent this, add the following line to your `wrangler.toml` file to make the environment compatible.

```
...
main = "src/index.ts"
compatibility_date = "2023-11-21"

node_compat = true # add this line
...
```

#### Testing the deploy

You can now redeploy using `wrangler deploy`

And perform a curl request to test your endpoint like such:

```
$ curl -X POST https://your-worker.your-subdomain.workers.dev \
-H "Content-Type: application/json" \
-d '{"proof": "someProof", "address": "someAddress", "tokenId": 0 }'

... invalid proof string ... 

# and if you replace with actual proof (from a wallet client login) and address on polygon, it should return 
success
```

## 4. Deploy & mint a collectible to wallet

Finally, to deploy and mint a collectible from the sponsored contract address, we install the following packages 

```
$ pnpm install @0xsequence/auth @0xsequence/network 
```

and implement the `callContract` and `getBlockNumber` methods previously mocked out as follows:

```ts
import { Session, SessionSettings } from '@0xsequence/auth'
import { networks, ChainId } from '@0xsequence/network'
...

const nodeUrl = 'https://nodes.sequence.app/arbitrum-nova'
const relayerUrl = 'https://arbitrum-nova-relayer.sequence.app'
const chainId = ChainId.ARBITRUM_NOVA
const provider = new ethers.providers.JsonRpcProvider(nodeUrl)
...

const getBlockNumber = async (request: Request): Promise<number> => {
	return await provider.getBlockNumber()
}

const callContract = async (request: Request, env: Env, address: string, tokenId: number): Promise<ethers.providers.TransactionResponse> => {

    const contractAddress = <deployed_contract_address>

    // create EOA from private key
	const walletEOA = new ethers.Wallet(env.PKEY, provider);

	// instantiate settings
	const settings: Partial<SessionSettings> = {
		networks: [{
			...networks[chainId],
			rpcUrl: nodeUrl,
			provider: provider, // NOTE: must pass the provider here
			relayer: {
				url: relayerUrl,
				provider: {
					url: nodeUrl
				}
			}
		}],
	}

    // create a single signer sequence wallet session
	const session = await Session.singleSigner({
		settings: settings,
		signer: walletEOA,
		projectAccessKey: '<access_key>'
	})

	const signer = session.account.getSigner(chainId)
		
	const collectibleInterface = new ethers.utils.Interface([
		'function mint(uint _tokenID, address collector)'
	])
		
	const data = collectibleInterface.encodeFunctionData(
		'mint', [tokenId, address] // minting only the first tokenID
	)

	const txn = { to: contractAddress, data }

	try {
		return await signer.sendTransaction(txn)
	} catch (err) {
		throw err
	}
}
```

Where in the prior code, an EOA wallet is instantiated from the environment variables uing `PKEY`, which should be set with the following commands:

```
$ wrangler secret put PKEY
# follow prompts
```

Once these steps are complete, you can redeploy and test with the steps outlined in this [prior step](/relayer/mint-collectible-severless#testing), and this time the POST request should return a transaction hash for the completed mint and the GET request would return a block number.

If you want to browse the full code, see [here](https://github.com/0xsequence-demos/cloudflare-worker-sequence-relayer/tree/simple-erc1155-mint-integration)

Good luck!