# Mint a Collectible using a Gasless Serverless Relayer

Time to complete: 15-30 minutes

The Sequence Relayer can be implemented on a severless [Cloudflare](https://cloudflare.com/) worker so a game or app user interaction is seamless without a confirmation signature or gas payment. You'll also benefit from not having to be worried about transaction speed, throughput and re-orgs by the relayer, and experience automatic scaling with cloudflare.

The following steps will guide you through how to build your technology in 4 steps:

1. [Setup Cloudflare environment with wrangler cli & deploy a test](/relayer/mint-collectible-severless#1-setup-cloudflare-environment-with-wrangler-cli--deploy-a-test)
2. [Write smart contract & deploy / sponsor with Builder](/relayer/mint-collectible-severless#2-write-smart-contract--deploy--sponsor-with-builder)
3. [Use EthAuthProof to prevent EOA DDoS](relayer/mint-collectible-severless#3-use-ethauthproof-to-prevent-eoa-ddos)
4. [Deploy & mint a collectible to wallet](relayer/mint-collectible-severless#4-deploy--mint-a-collectible-to-wallet)

The result, a secure API with the following specs:
* HTTPS GET: returns blockNumber
* HTTPS POST(proof, address): mints a collectible & returns transaction hash

## 1. Setup Cloudflare environment with wrangler cli & deploy a test

In order to create the project from scratch, first create a project with `mkdir`, `cd` into the project, and run `pnpm init` to create a `package.json`.

Next, make sure wrangler cli is installed in your project and set the `wrangler` keyword as an alias in your local bash session.

```
$ pnpm install wrangler --save-dev
$ alias wrangler='./node_modules/.bin/wrangler'
```

Create an account on the [Cloudflare site](https://cloudflare.com/) and perform a login step to login to your cloudflare dashboard to connect the Cloudflare platform to your local development environment.

```
$ wrangler login
```

Once logged in, initialize the project in the project directory and follow the prompts to deploy your typescript `"Hello World" Worker` application

```
$ wrangler init
```

This will clone down a starter repository that can be used to deploy code to the cloud.

Once initialized the last step before deployment is to register a sub-domain.

#### Register your cloudflare sub-domain

On the [Cloudflare site](https://cloudflare.com/) create the workers.dev subdomain in Workers & Pages > select your Worker > Your subdomain > Change.

And if you haven't already deployed your code, you can do so after you've `cd`'ed into the generated app folder (should be some random name from the `wrangler init` step) and:

```
$ wrangler deploy
```

Finally, enter the generated `https://<app>.workers.dev` link in the browser and view response.

## 2. Write smart contract & deploy / sponsor with Builder

Write your smart contract with the necessary features, for example, here is the recommended contract that adds a few features like: only being able to mint from the relayer, the ability to turn on and off the mint, and a contract owner with certain privileges.

```sol

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

contract Demo is ERC1155 {
    bool public minting;
    address public relayerAddress;
    address public ownerAddress;

    modifier onlyRelayer(){
        require(msg.sender == relayerAddress);
        _;
    }

    modifier onlyOwner(){
        require(msg.sender == ownerAddress);
        _;
    }

    constructor(address _relayerAddress) ERC1155("https://<your_metadata>/{id}.json") {
        relayerAddress = _relayerAddress;
        ownerAddress = msg.sender;
        minting = true;
    }

    function mint(uint _tokenID, address collector) onlyRelayer external {
        require(minting, "contract not minting");
        _mint(collector, _tokenID, 1, "");
    }

    function setMinting(bool _state) onlyOwner external {
        minting = _state;
    }
}
```

Compile your code with one of the popular frameworks (like forge, hardhat, etc.) and follow the steps below to upload and deploy your contract in the [Sequence Builder](https://sequence.build).

Then, access the contract page once you've [created a project](https://www.youtube.com/watch?v=UAHxmO27KrA&list=PLN_CsIpJBRiiJ7MAKrWSXj1oxWTJfiEir&index=1) and select `+ View more contracts`

![contract page in builder](/img/relayer/contracts_page.png)

And select `+ Upload Source`

![view more options](/img/relayer/view_more_options.png)

Finally, name your contract and upload your abi file generated locally before deploying your contract with `Upload Contract Source` and completing the onchain transaction to deploy to your selected network.

![contract source](/img/relayer/contract_source.png)

Once you've completed the steps, you'll find in the contracts page your contract address you'll need for the sending transactions to in the code.

## 3. Use EthAuthProof to prevent EOA DDoS

Next, install `ethers` and `0xsequence` to get access to sequence APIs in order to perform a proof validation that the request is coming from a trusted source, a sequence wallet.

```
$ pnpm install 0xsequence ethers@5.7.2
```

Then, we have to add a type of middleware, after we check if it's a POST or GET request. If it's a POST request, verify that the passed in `proofString` and `address` are valid.  

The code scaffold would look like this, with `callContract` and `getBlockNumber` mocked out.

```ts
import { sequence } from '0xsequence'
import { ethers } from 'ethers'

export interface Env {
	PKEY: string
}

// use the sequence api to verify proof came from a sequence wallet
const verify = async (chainId: string, walletAddress: string, ethAuthProofString: string): Promise<Boolean> => {
	const api = new sequence.api.SequenceAPIClient('https://api.sequence.app')
	const { isValid } = await api.isValidETHAuthProof({
		chainId, walletAddress, ethAuthProofString
	})
	return isValid
}

async function handleRequest(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
	if (env.PKEY === undefined || env.PKEY === '') {
		console.log('ooops! check your wranger.toml config to set your PKEY')
	}

	// POST request
	if (request.method === "POST") {
		// parse the request body as JSON
		const body = await request.json();
		const { proof, address }: any = body;
		try {
			// check that the proof is valid
			if(await verify('polygon', address, proof)){
				try{
					// mocked call
					const res = await callContract(request, env, address)
					return new Response(`${res.hash}`, { status: 200 })
				} catch (err: any) {
					console.log(err)
					return new Response(`Something went wrong: ${JSON.stringify(err)}`, { status: 400 })
				}
			} else {
				return new Response(`Unauthorized`, { status: 401 })
			}
		} catch(err: any){
			return new Response(`Unauthorized ${JSON.stringify(err)}`, { status: 401 })
		}
	} 
	// GET request
	else {
		try {
			// mocked call
			const res = await getBlockNumber(request)
			return new Response(`Block Number: ${res}`)
		} catch(err: any){
			return new Response(`Something went wrong: ${JSON.stringify(err)}`, { status: 400 })
		}
	}
}

const getBlockNumber = async (request: Request): Promise<number> => {
	return 0
}

const callContract = async (request: Request, env: Env, address: string): Promise<ethers.providers.TransactionResponse> => {
	return { hash: "0x" } as any
}

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext) {
		// Process the request and create a response
		const response = await handleRequest(request, env, ctx);

		// Set CORS headers
		response.headers.set("Access-Control-Allow-Origin", "*");
		response.headers.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
		response.headers.set("Access-Control-Allow-Headers", "Content-Type");

		// return response
		return response;
	}
};
```

#### Implement window object in wrangler template

It should be noted, if you try to deploy this you'll get a missing `window` object required by the web3 modules. 

To prevent this, add the following line to your `wrangler.toml` file to make the environment compatible.

```
...
main = "src/index.ts"
compatibility_date = "2023-11-21"

node_compat = true # add this line
...
```

#### Testing the deploy

You can now redeploy using `wrangler deploy`

And perform a curl request to test your endpoint like such:

```
$ curl -X POST https://your-worker.your-subdomain.workers.dev \
-H "Content-Type: application/json" \
-d '{"proof": "someProof", "address": "someAddress"}'

... invalid proof string ... 

# and if you replace with actual proof (from a wallet client login) and address on polygon, it should return 
success
```

## 4. Deploy & mint a collectible to wallet

Finally, we install the following packages 

```
$ pnpm install @0xsequence/auth @0xsequence/network 
```

and implement the `callContract` and `getBlockNumber` methods previously mocked out as follows:

```ts
import { Session, SessionSettings } from '@0xsequence/auth'
import { networks, ChainId } from '@0xsequence/network'
...

const nodeUrl = 'https://nodes.sequence.app/polygon'
const relayerUrl = 'https://polygon-relayer.sequence.app'
const chainId = ChainId.POLYGON

...

const getBlockNumber = async (request: Request): Promise<number> => {
	return await provider.getBlockNumber()
}

const callContract = async (request: Request, env: Env, address: string): Promise<ethers.providers.TransactionResponse> => {

    const contractAddress = <deployed_contract_address>

    // create EOA from private key
	const walletEOA = new ethers.Wallet(env.PKEY, provider);

	// instantiate settings
	const settings: Partial<SessionSettings> = {
		networks: [{
			...networks[ChainId.POLYGON],
			rpcUrl: nodeUrl,
			provider: provider, // NOTE: must pass the provider here
			relayer: {
				url: relayerUrl,
				provider: {
					url: nodeUrl
				}
			}
		}],
	}

    // create a single signer sequence wallet session
	const session = await Session.singleSigner({
		settings: settings,
		signer: walletEOA,
	})

	const signer = session.account.getSigner(chainId)
		
	const collectibleInterface = new ethers.utils.Interface([
		'function mint(uint _tokenID, address collector)'
	])
		
	const data = collectibleInterface.encodeFunctionData(
		'mint', [0, address] // minting only the first tokenID
	)

	const txn = { to: contractAddress, data }

	try {
		return await signer.sendTransaction(txn)
	} catch (err) {
		throw err
	}
}
```

Where in the prior code, an EOA wallet is instantiated from the environment variables uing `PKEY`, which should be set with the following commands:

```
$ wrangler secret put PKEY
# follow prompts
```

Once these steps are complete, you can redeploy and test with the steps outlined in this [prior step](/relayer/mint-collectible-severless#testing), and this time the POST request should return a transaction hash for the completed mint and the GET request would return a block number.

If you want to browse the full code, see [here](https://github.com/0xsequence-demos/cloudflare-worker-sequence-relayer/tree/simple-erc1155-mint-integration)

Good luck!